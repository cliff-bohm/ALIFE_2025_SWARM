# this file will display the output generated by berry world 
# run in visualization mode.

# provide path to HarvestWorldData file in FileName
# left and right arrows alter fps
# left mouse pauses and restarts



fileName = 'c:/Users/cliff/slimBerry/experiment_4_data/data_assets/C2_314/eval_0/HarvestWorldData.txt'
#fileName = 'c:/Users/cliff/slimBerry/evalMaxNavWorld/data_assets/C0_306/eval_0/harvestin0'
#fileName = 'c:/Users/cliff/slimBerry/evalMaxNavWorld/data_assets/C0_201/eval_0/harvestin0'

windowSize = 1000

fps = 1 # can also be adjusted with left and right arrows

colorHarvesters = True 
clonesHaveSameColor = False

# draw paths
showPath = False

pathLength = 500
pathWidthMin = 0
pathWidthMax = 5

# spaceColors
spaceColors = [
color(0,0,0),
color(0,125,0),
color(50,255,50),
color(0,0,255),
color(0,255,255),
color(255,0,255),
color(255,255,0),
color(255,127,0),
color(127,255,0),
color(100,100,100)
]

# harvester Colors
harvesterColors = [
color(255,127,127),
color(0,255,0),
color(127,127,255),
color(0,255,255),
color(255,0,255),
color(255,255,0),
color(255,255,255),
color(127,255,0),
color(255,127,0),
color(127,0,255),
color(255,0,127),
color(0,127,255),
color(0,255,127),
color(255,255,127),
color(255,127,255),
color(127,255,255),
color(127,127,255),
color(127,255,127),
color(255,127,127)
]

t_4 = color(255,0,255)
t_3 = color(100,100,255)
t_2 = color(255,100,100)
t_1 = color(255,255,255)

harvesterColors = [t_1,t_1,t_3,t_1,t_4,t_2,t_2,t_3]

############################################################
##
##  do not edit below this line
##
############################################################

# global vars
fileHandle = open(fileName, 'r+')

playthough = 0

directions = 8
worldX = 20
worldY = 20
worldTime = -1
world = []
harvesters = {}

mode = 1

gridSize = 30
foodSize = 28
offset = 0

def mousePressed():
    global mode
    if mode == 1:
        noLoop()
        mode = 0
    elif mode == 0:
        loop()
        mode = 1

def keyPressed():
    global fps
    if key == CODED:
        if (keyCode == RIGHT):
            fps = fps * 2
            frameRate(fps)
        if (keyCode == LEFT):
            fps = fps / 2;
            if (fps<1):
                fps = 1;
            frameRate(fps);

#def readNextLineFromFile():
#    global fileHandle
#    line = fileHandle.readline().strip()
#    while (line == ""):
#        line = fileHandle.readline().strip()
#    splitLine = split(line,',')
#    return splitLine

def readNextLineFromFile():
    global fileHandle
    global playthough
    line = fileHandle.readline()
    if not line:
        fileHandle.seek(0)
        line = fileHandle.readline()
    line = line.strip()
    # Only treat an explicit "EOF" as end-of-data
    if line == "EOF":
        fileHandle.seek(0)
        playthough = 0
        line = fileHandle.readline().strip()
    return split(line, ',')

class Harvester:
    
    def __init__(self, x, y, f):
        global colorHarvesters
        self.x = x
        self.y = y
        self.f = f
        self.lx = x
        self.ly = y
        self.lf = f
        self.path = [[x,y]]
        if colorHarvesters:
            self.fillColor = color(random(125,255),random(125,255),random(125,255),255)
            self.strokeColor = color(0,0,0,255)
        else:
            self.fillColor = color(0,0,0,255)
            self.strokeColor = color(0,0,0,255)
        
    def move(self, x, y):
        self.x = x
        self.y = y
        self.path.append([x,y])
        
    def turn(self, f):
        self.f = f

def loadWorld():
    global directions
    global worldX
    global worldY
    global groupSize
    global gridSize
    global foodSize
    global offset
    global world
    global worldX
    global worldY
    splitLine = readNextLineFromFile()
    directions = int(splitLine[0])
    worldX = int(splitLine[1])
    worldY = int(splitLine[2])
    groupSize = int(splitLine[3])
    gridSize = windowSize/worldX
    foodSize = gridSize*.9
    offset = (gridSize-foodSize)/2
    world = []
    for y in range(worldY):
        splitLine = readNextLineFromFile()
        for x in range(worldX):
            world.append(int(splitLine[x]))

def loadHarvesters():
    global harvesters
    global groupSize
    harvesters = {}
    for i in range(groupSize):
        splitLine = readNextLineFromFile();
        harvesters[i] = Harvester(float(splitLine[1]),float(splitLine[2]),int(splitLine[3]))
        if colorHarvesters:
            if (i<len(harvesterColors)):
                harvesters[i].fillColor = harvesterColors[i]
            if (clonesHaveSameColor):
                harvesters[i].fillColor = harvesters[int(splitLine[4])].fillColor


def drawWorld():
    global world
    global gridSize
    global foodSize
    global offset
    global worldX
    global worldY
    global spaceColors
    for xx in range(worldX*worldY):
        fill(spaceColors[world[xx]])
        strokeWeight(0)
        rect((xx % worldX) * gridSize + offset,int(xx/worldX) * gridSize + offset,foodSize,foodSize)

def drawHarvesters():
    global harvesters
    global directions
    for i in range(len(harvesters)):        
        pushMatrix()
        translate((harvesters[i].x * gridSize),(harvesters[i].y * gridSize))
        rotate(radians(harvesters[i].f*(360.0/directions)))
        fill(harvesters[i].fillColor)
        strokeWeight(1)
        stroke(harvesters[i].strokeColor)
        triangle(gridSize*-.3, gridSize*.5, gridSize*.3, gridSize*.5, 0, gridSize*-.5)
        popMatrix()
        
        # Draw ID number above the triangle
        fill(0)
        textAlign(CENTER, BOTTOM)
        textSize(gridSize * 0.4)
        if harvesters[i].f == 0:
            text(str(i+1), (harvesters[i].x) * gridSize, (harvesters[i].y + .25) * gridSize + gridSize * 0.225)
        if harvesters[i].f == 1:
            text(str(i+1), (harvesters[i].x - .25) * gridSize, harvesters[i].y * gridSize + gridSize * 0.225)
        if harvesters[i].f == 2:
            text(str(i+1), (harvesters[i].x) * gridSize, (harvesters[i].y - .25) * gridSize + gridSize * 0.225)
        if harvesters[i].f == 3:
            text(str(i+1), (harvesters[i].x + .24) * gridSize, (harvesters[i].y) * gridSize + gridSize * 0.225)


def drawPaths():
    global harvesters
    global gridSize
    global pathLength
    global pathWidthMax
    global pathWidthMin
    global worldX
    global worldY

    for i in harvesters:
        j = len(harvesters[i].path)-1
        l = 1;
        while l < pathLength and j > 0:
            p1 = harvesters[i].path[j]
            p2 = harvesters[i].path[j-1]
            if (abs(p1[0]-p2[0]) < (worldX/2) and abs(p1[1]-p2[1]) < (worldY/2)):
                stroke(harvesters[i].fillColor)
                
                strokeWeight  (      float(pathWidthMin)  *  (float(l) / float(pathLength) ) + ( float(pathWidthMax) * (float(pathLength) - float(l)) / float(pathLength) )   )
                line(p1[0]*gridSize,p1[1]*gridSize,p2[0]*gridSize,p2[1]*gridSize)
                stroke(255,255,255,255)
                strokeWeight(1)
            j-=1
            l+=1
           
def setup():
    global fileHandle
    global fps
    global directions
    global worldX
    global worldY
    global groupSize
    global mode
    global gridSize
    global foodSize
    global offset
    global windowSize
    background(0)
    stroke(255)
    frameRate(fps)
    size(windowSize, windowSize)#3000,500) # for Nav
    smooth(30)
  
def draw():
    global world
    global harvesters
    global worldTime
    global fps
    global mode
    global gridSize
    global playthough
    
    newUpdate = False
    
    while not newUpdate:
        splitLine = readNextLineFromFile()
    
        if (splitLine[0] == "**InitializeWorld**"):
            playthough+=1
            loadWorld()

        if (splitLine[0] == "**InitializeHarvesters**"):
            loadHarvesters()

        if (splitLine[0]=="U"):
            worldTime = int(splitLine[1]);
            if (worldTime%(max(1,int(fps/30.0))) is 0):
                background(0)
                drawWorld()
                if showPath:
                    drawPaths()
                drawHarvesters()

                fill(255,255,255)
                stroke(255,255,255)
                strokeWeight(2)
                textSize(gridSize*.75)
                textAlign(LEFT, BOTTOM)
                #text("iteration: " + str(playthough)+"  time: " + str(worldTime) + "   fps: " + str(fps), 20, gridSize*.45)
                text("Update: " + str(worldTime), 20, gridSize*.87)
                strokeWeight(1)


            newUpdate = True
        if (splitLine[0]=="E"):
            world[(int(splitLine[2]) * worldX) + int(splitLine[1])] = 0
        if (splitLine[0]=="R"):
            world[(int(splitLine[2]) * worldX) + int(splitLine[1])] = int(splitLine[3])
        if (splitLine[0]=="I"):
            world[(int(splitLine[2]) * worldX) + int(splitLine[1])] = int(splitLine[3])
        if (splitLine[0]=="TR"):
            harvesters[int(splitLine[1])].turn(int(splitLine[2]))
        if (splitLine[0]=="TL"):
            harvesters[int(splitLine[1])].turn(int(splitLine[2]))
        if (splitLine[0]=="M"):
            harvesters[int(splitLine[1])].move(float(splitLine[2]),float(splitLine[3]))
        #noLoop()

    
